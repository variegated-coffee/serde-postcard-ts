/**
 * Rust compatibility tests
 * Validates that TypeScript can deserialize binary data generated by Rust postcard
 */

import { describe, it, expect, beforeAll } from "vitest";
import { readFileSync } from "fs";
import { join } from "path";
import { deserialize } from "../../src/codec/deserializer.js";
import {
  PrimitivesSchema,
  CollectionsSchema,
  ComplexEnumSchema,
  NestedSchema,
  EdgeCasesSchema,
  NewtypeStructSchema,
  UnitStructSchema,
  TupleStructSchema,
  GameStateSchema,
} from "../fixtures/schemas.js";
import type {
  Primitives,
  Collections,
  ComplexEnum,
  Nested,
  EdgeCases,
  NewtypeStruct,
  UnitStruct,
  TupleStruct,
  GameState,
} from "../fixtures/schemas.js";

// Helper to load binary fixture
function loadFixture(filename: string): Uint8Array {
  const path = join(process.cwd(), "test-fixtures", "fixtures", filename);
  return new Uint8Array(readFileSync(path));
}

describe("Rust postcard compatibility", () => {
  beforeAll(() => {
    // TODO: Ensure fixtures are generated
    // Can be done by checking if files exist or running cargo
  });

  describe("Primitives", () => {
    it("should deserialize primitives struct from Rust", () => {
      const data = loadFixture("primitives.bin");
      const result = deserialize(PrimitivesSchema, data);

      expect(result.value.bool_field).toBe(true);
      expect(result.value.i8_field).toBe(-42);
      expect(result.value.i16_field).toBe(-1000);
      expect(result.value.i32_field).toBe(-100000);
      expect(result.value.i64_field).toBe(-10000000000n);
      expect(result.value.i128_field).toBe(-123456789012345678901234567890n);
      expect(result.value.u8_field).toBe(255);
      expect(result.value.u16_field).toBe(65535);
      expect(result.value.u32_field).toBe(4294967295);
      expect(result.value.u64_field).toBe(18446744073709551615n);
      expect(result.value.u128_field).toBe(340282366920938463463374607431768211455n);
      expect(result.value.f32_field).toBeCloseTo(-32.005859375, 5);
      expect(result.value.f64_field).toBe(-32.005859375);
      expect(result.value.char_field).toBe("ðŸ¦€");
      expect(result.value.string_field).toBe("Hello, postcard!");
    });
  });

  describe("Collections", () => {
    it("should deserialize collections struct from Rust", () => {
      const data = loadFixture("collections.bin");
      const result = deserialize(CollectionsSchema, data);

      expect(result.value.vec_u8).toEqual([1, 2, 3, 4, 5]);
      expect(result.value.vec_string).toEqual(["one", "two", "three"]);
      expect(result.value.array_u32).toEqual([100, 200, 300, 400]); // Tuple is represented as array
      expect(result.value.tuple_mixed).toEqual([42, "test", true]);
      expect(result.value.option_some).toBe(12345);
      expect(result.value.option_none).toBe(null);
    });
  });

  describe("Enums", () => {
    it("should deserialize unit variant from Rust", () => {
      const data = loadFixture("enum_unit.bin");
      const result = deserialize(ComplexEnumSchema, data);

      expect(result.value.type).toBe("UnitVariant");
    });

    it("should deserialize newtype variant from Rust", () => {
      const data = loadFixture("enum_newtype.bin");
      const result = deserialize(ComplexEnumSchema, data);

      expect(result.value.type).toBe("NewtypeVariant");
      if (result.value.type === "NewtypeVariant") {
        expect(result.value.value).toBe(999);
      }
    });

    it("should deserialize tuple variant from Rust", () => {
      const data = loadFixture("enum_tuple.bin");
      const result = deserialize(ComplexEnumSchema, data);

      expect(result.value.type).toBe("TupleVariant");
      if (result.value.type === "TupleVariant") {
        expect(result.value.value).toEqual(["tuple", -500, false]);
      }
    });

    it("should deserialize struct variant from Rust", () => {
      const data = loadFixture("enum_struct.bin");
      const result = deserialize(ComplexEnumSchema, data);

      expect(result.value.type).toBe("StructVariant");
      if (result.value.type === "StructVariant") {
        expect(result.value.value.x).toBeCloseTo(3.14159, 5);
        expect(result.value.value.y).toBeCloseTo(2.71828, 5);
        expect(result.value.value.label).toBe("point");
      }
    });
  });

  describe("Nested structures", () => {
    it("should deserialize nested struct with HashMap from Rust", () => {
      const data = loadFixture("nested.bin");
      const result = deserialize(NestedSchema, data);

      expect(result.value.inner.id).toBe(12345n);
      expect(result.value.inner.name).toBe("primary");

      // Map can have entries in any order
      expect(result.value.map.size).toBe(3);
      expect(result.value.map.get("alice")).toBe(100);
      expect(result.value.map.get("bob")).toBe(200);
      expect(result.value.map.get("charlie")).toBe(300);

      expect(result.value.vec_of_structs).toHaveLength(2);
      expect(result.value.vec_of_structs[0]?.id).toBe(1n);
      expect(result.value.vec_of_structs[0]?.name).toBe("first");
      expect(result.value.vec_of_structs[1]?.id).toBe(2n);
      expect(result.value.vec_of_structs[1]?.name).toBe("second");
    });
  });

  describe("Edge cases", () => {
    it("should deserialize edge cases from Rust", () => {
      const data = loadFixture("edge_cases.bin");
      const result = deserialize(EdgeCasesSchema, data);

      expect(result.value.empty_vec).toEqual([]);
      expect(result.value.empty_string).toBe("");
      expect(result.value.zero).toBe(0n);
      expect(result.value.max_u8).toBe(255);
      expect(result.value.min_i8).toBe(-128);
      expect(result.value.max_i8).toBe(127);
      expect(result.value.max_u16).toBe(65535);
      expect(result.value.max_u32).toBe(4294967295);
      expect(result.value.negative).toBe(-999999);
    });
  });

  describe("Special struct types", () => {
    it("should deserialize newtype struct from Rust", () => {
      const data = loadFixture("newtype_struct.bin");
      const result = deserialize(NewtypeStructSchema, data);

      expect(result.value).toBe(987654321n);
    });

    it("should deserialize unit struct from Rust", () => {
      const data = loadFixture("unit_struct.bin");
      const result = deserialize(UnitStructSchema, data);

      expect(result.value).toEqual({});
    });

    it("should deserialize tuple struct from Rust", () => {
      const data = loadFixture("tuple_struct.bin");
      const result = deserialize(TupleStructSchema, data);

      expect(result.value).toEqual(["tuple_data", 777, true]);
    });
  });

  describe("Complex Integration - Game State", () => {
    it("should deserialize complete game state with deep nesting", () => {
      const data = loadFixture("game_state.bin");
      const result = deserialize(GameStateSchema, data);
      const game = result.value;

      // Validate player data
      expect(game.player.id).toBe(12345n);
      expect(game.player.name).toBe("Hero");
      expect(game.player.position.x).toBe(10.5);
      expect(game.player.position.y).toBe(20.3);
      expect(game.player.position.z).toBe(5.0);
      expect(game.player.health).toBeCloseTo(85.5, 1);
      expect(game.player.mana).toBe(120);

      // Validate nested inventory
      expect(game.player.inventory.capacity).toBe(20);
      expect(game.player.inventory.gold).toBe(1500);
      expect(game.player.inventory.items).toHaveLength(3);

      // Validate inventory items (enum variants)
      const item0 = game.player.inventory.items[0];
      expect(item0?.type).toBe("Consumable");
      if (item0?.type === "Consumable") {
        expect(item0.value.name).toBe("Health Potion");
        expect(item0.value.quantity).toBe(5);
      }

      const item1 = game.player.inventory.items[1];
      expect(item1?.type).toBe("Weapon");
      if (item1?.type === "Weapon") {
        expect(item1.value.name).toBe("Flaming Sword");
        expect(item1.value.damage).toBe(50);
        expect(item1.value.element?.type).toBe("Fire");
      }

      const item2 = game.player.inventory.items[2];
      expect(item2?.type).toBe("Armor");
      if (item2?.type === "Armor") {
        expect(item2.value.defense).toBe(30);
        expect(item2.value.durability).toBe(95);
      }

      // Validate optional equipped weapon
      expect(game.player.equipped).not.toBeNull();
      if (game.player.equipped) {
        expect(game.player.equipped.name).toBe("Frost Bow");
        expect(game.player.equipped.damage).toBe(35);
        expect(game.player.equipped.element?.type).toBe("Ice");
      }

      // Validate enemies (all 4 enum variant types)
      expect(game.enemies).toHaveLength(4);

      const enemy0 = game.enemies[0];
      expect(enemy0?.type).toBe("Goblin");
      if (enemy0?.type === "Goblin") {
        expect(enemy0.value.id).toBe(1);
        expect(enemy0.value.aggro).toBe(true);
      }

      const enemy1 = game.enemies[1];
      expect(enemy1?.type).toBe("Dragon");
      if (enemy1?.type === "Dragon") {
        expect(enemy1.value.color.type).toBe("Red");
        expect(enemy1.value.age).toBe(500);
      }

      const enemy2 = game.enemies[2];
      expect(enemy2?.type).toBe("Skeleton");

      const enemy3 = game.enemies[3];
      expect(enemy3?.type).toBe("Boss");
      if (enemy3?.type === "Boss") {
        expect(enemy3.value.name).toBe("Dark Lord");
        expect(enemy3.value.phase).toBe(2);
        expect(enemy3.value.health_percent).toBeCloseTo(65.8, 1);
      }

      // Validate world with HashMap of locations
      expect(game.world.name).toBe("Realm of Testing");
      expect(game.world.locations.size).toBe(3);

      const forest = game.world.locations.get("forest");
      expect(forest?.description).toBe("Dense woodland");
      expect(forest?.coordinates.x).toBe(0.0);
      expect(forest?.coordinates.y).toBe(0.0);
      expect(forest?.coordinates.z).toBe(0.0);
      expect(forest?.visited).toBe(true);

      const cave = game.world.locations.get("cave");
      expect(cave?.description).toBe("Dark cavern");
      expect(cave?.coordinates.x).toBe(15.0);
      expect(cave?.visited).toBe(false);

      const castle = game.world.locations.get("castle");
      expect(castle?.description).toBe("Ancient fortress");
      expect(castle?.coordinates.x).toBe(100.0);

      // Validate optional boss
      expect(game.world.boss).not.toBeNull();
      if (game.world.boss) {
        expect(game.world.boss.name).toBe("The Final Test");
        expect(game.world.boss.difficulty).toBe(10);
      }

      // Validate game events (nested enums)
      expect(game.events).toHaveLength(5);

      const event0 = game.events[0];
      expect(event0?.type).toBe("PlayerAction");
      if (event0?.type === "PlayerAction") {
        expect(event0.value.type).toBe("Move");
        if (event0.value.type === "Move") {
          expect(event0.value.value.from.x).toBe(0.0);
          expect(event0.value.value.to.x).toBe(10.5);
          expect(event0.value.value.to.y).toBe(20.3);
        }
      }

      const event1 = game.events[1];
      expect(event1?.type).toBe("EnemySpawn");
      if (event1?.type === "EnemySpawn") {
        expect(event1.value.enemy_type).toBe("Goblin");
        expect(event1.value.count).toBe(3);
      }

      const event2 = game.events[2];
      expect(event2?.type).toBe("ItemDropped");
      if (event2?.type === "ItemDropped") {
        expect(event2.value.type).toBe("Consumable");
        if (event2.value.type === "Consumable") {
          expect(event2.value.value.name).toBe("Mana Potion");
          expect(event2.value.value.quantity).toBe(2);
        }
      }

      const event3 = game.events[3];
      expect(event3?.type).toBe("PlayerAction");
      if (event3?.type === "PlayerAction") {
        expect(event3.value.type).toBe("Attack");
        if (event3.value.type === "Attack") {
          expect(event3.value.value.target_id).toBe(1);
        }
      }

      const event4 = game.events[4];
      expect(event4?.type).toBe("LocationDiscovered");
      if (event4?.type === "LocationDiscovered") {
        expect(event4.value).toBe("cave");
      }

      // Validate metadata
      expect(game.metadata.version).toBe("1.0.0");
      expect(game.metadata.timestamp).toBe(1699000000n);
      expect(game.metadata.difficulty.type).toBe("Normal");
    });
  });
});
